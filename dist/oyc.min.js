// src/utils.js
function findOnElements(parent) {
  const xpathResults = document.evaluate(
    '//*[@*[ starts-with(name(), "oyc-on:") or starts-with(name(), "data-oyc-on:") ]]',
    parent
  );
  let element = null;
  const elements = [];
  while (element = xpathResults.iterateNext()) {
    elements.push(element);
  }
  return elements;
}
function hasAttribute(element, name) {
  return element.hasAttribute(name) || element.hasAttribute("data-" + name);
}
function getAttribute(element, name) {
  return element.getAttribute(name) || element.getAttribute("data-" + name);
}
function parseInterval(time) {
  if (time === void 0) {
    return void 0;
  }
  let value = parseFloat(time);
  let unit = time.replace(value, "");
  switch (unit) {
    case "ms":
      return value;
    case "s":
      return value * 1e3;
    case "m":
      return value * 6e4;
    default:
      console.warn("[OYC] Invalid time interval: " + time);
      return void 0;
  }
}

// src/oyc.js
var oycDataAttribute = "oyc-data";
var httpMethods = ["get", "post", "put", "patch", "delete", "head"];
var methodSelector = httpMethods.flatMap((method) => [`[oyc-${method}]`, `[data-oyc-${method}]`]).join(",");
var oycAttributes = ["trigger"];
var oycAttributeSelector = oycAttributes.flatMap((attribute) => [`[oyc-${attribute}]`, `[data-oyc-${attribute}]`]).join(",");
var defaultTrigger = {
  event: "click",
  modifiers: void 0
};
var Oyc = class {
  ready = document.readyState === "complete";
  on = addEventListener;
  off = removeEventListener;
  getOycData = getData;
  process = processElementAndChildren;
  constructor() {
    if (this.ready == false) {
      document.addEventListener("readystatechange", (event) => {
        if (event.target.readyState === "complete") {
          this.ready = true;
        }
      });
    }
    this.onReady(function() {
      processElementAndChildren(document.body);
    });
  }
  /**
   * Execute a function now if DOMContentLoaded has fired, otherwise listen for it.
   *
   */
  onReady(fn) {
    if (this.ready) {
      fn();
    } else {
      document.addEventListener("readystatechange", (event) => {
        if (event.target.readyState === "complete") {
          fn();
        }
      });
    }
  }
};
async function handleFetch(method, url, element) {
  const response = await fetch(url, {
    method: method.toUpperCase()
  });
  if (response.ok) {
    const html = await response.text();
    swapHTML(element, html);
  }
}
function swapHTML(element, html) {
  element.innerHTML = html;
}
function addTriggerHandler(element, listener) {
  const trigger = parseTrigger(getAttribute(element, "oyc-trigger"));
  if (trigger) {
    addEventListener(element, trigger.event, listener, trigger.modifiers);
  } else {
    addEventListener(
      element,
      defaultTrigger.event,
      listener,
      defaultTrigger.modifiers
    );
  }
}
function processElement(element) {
  for (let index = 0; index < httpMethods.length; index++) {
    if (hasAttribute(element, "oyc-" + httpMethods[index])) {
      addTriggerHandler(element, function(event) {
        void handleFetch(
          httpMethods[index],
          getAttribute(element, "oyc-" + httpMethods[index]),
          event.target
        );
      });
    }
  }
}
function addCustomEventListeners(element) {
  removeCustomEventListeners(element);
  findOnElements(element).forEach((element2) => {
    const data = getData(element2);
    data.onEventHandlers = [];
    for (let index = 0; index < element2.attributes.length; index++) {
      const attribute = element2.attributes[index];
      if (attribute.name.startsWith("oyc-on:") || attribute.name.startsWith("data-oyc-on:")) {
        const event = attribute.name.slice(attribute.name.indexOf(":") + 1);
        const listener = attribute.value;
        const trigger = parseTrigger(getAttribute(element2, "oyc-trigger"));
        if (trigger) {
          addEventListener(
            element2,
            trigger.event,
            window[listener],
            trigger.modifiers
          );
        } else {
          addEventListener(element2, event, window[listener], void 0);
        }
        data.onEventHandlers.push({
          event,
          listener
        });
      }
    }
  });
}
function removeCustomEventListeners(element) {
  const data = getData(element);
  if (data.onEventHandlers) {
    for (let index = 0; index < data.onHandlers.length; index++) {
      element.removeEventListener(handler.event, handler.listener);
    }
    delete data.onEventHandlers;
  }
}
function addEventListener(element, eventName, listener, modifier) {
  if (!modifier || Object.keys(modifier).length === 0) {
    element.addEventListener(eventName, listener);
    return;
  }
  const listenerWrapper = function(event) {
    if (modifier.delay) {
      setTimeout(() => {
        listener(event);
      }, modifier.delay);
      return;
    }
    if (modifier.throttle) {
      throw new Error("Throttle is not yet implemented");
    }
    if (modifier.debounce) {
      throw new Error("Debounce is not yet implemented");
    }
    listener(event);
  };
  element.addEventListener(eventName, listenerWrapper, modifier);
}
function removeEventListener(element, eventName, listener) {
  element.removeEventListener(eventName, listener);
}
function processElementAndChildren(element) {
  processElement(element);
  const children = findElementsToProcess(element);
  for (let i = 0; i < children.length; i++) {
    processElement(children[i]);
  }
  addCustomEventListeners(element);
}
function getData(element) {
  return element[oycDataAttribute] || {};
}
function findElementsToProcess(element) {
  if (element.querySelectorAll) {
    return element.querySelectorAll(
      methodSelector + "," + oycAttributeSelector
    );
  } else {
    return [];
  }
}
function parseTrigger(triggerString) {
  if (!triggerString) {
    return void 0;
  }
  let parts = triggerString.split(" ");
  const event = parts[0];
  const modifiers = {};
  for (let index = 1; index < parts.length; index++) {
    const modifier = parts[index].trim();
    if (!parts[index].trim()) {
      continue;
    }
    switch (modifier) {
      case "once":
      case "prevent":
      case "capture":
      case "passive": {
        modifiers[modifier] = true;
        continue;
      }
    }
    const complexPart = modifier.split(":");
    const name = complexPart[0];
    const value = complexPart[1];
    switch (name) {
      case "poll":
      case "delay":
      case "throttle":
      case "debounce": {
        modifiers[name] = parseInterval(value);
        continue;
      }
    }
  }
  return {
    event,
    modifiers
  };
}
var oyc = new Oyc();
if (typeof window !== "undefined") {
  window.oyc = oyc;
}
export {
  Oyc,
  oyc
};
