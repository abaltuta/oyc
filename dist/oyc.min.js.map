{
  "version": 3,
  "sources": ["../src/dom.js", "../src/fetch.js", "../src/static.js", "../src/utils.js", "../src/attributes.js", "../src/oyc.js"],
  "sourcesContent": ["import { processElementAndChildren } from \"./oyc.js\";\r\n// We reuse the DOMParser instead of creating a new one\r\nconst domParser = new DOMParser();\r\n\r\n/**\r\n * Parses an HTML string and returns a document fragment containing the parsed HTML.\r\n * @param {string} htmlString - The HTML string to parse.\r\n * @param {string} [outputSelector] - Optional CSS selector for selecting a specific element from the parsed HTML.\r\n * @returns {DocumentFragment | Element} - The parsed HTML as a document fragment or a selected element.\r\n */\r\nexport function parseHTML(htmlString, outputSelector) {\r\n  // TODO: Support full body refreshes and title changes\r\n  // We wrap the html string inside a body tag\r\n  // Looking at the htmx part of the code this appears to avoid some weirdness around parsing `table` tags and friends\r\n  // TODO: verify this assumption\r\n  // TODO: handle scripts\r\n  const parsedHTML = domParser.parseFromString(\r\n    `<body><template>${htmlString}</template></body>`,\r\n    \"text/html\"\r\n  ).querySelector(\"template\").content;\r\n\r\n\r\n  if (outputSelector) {\r\n    return parsedHTML.querySelector(outputSelector);\r\n  }\r\n\r\n  return parsedHTML;\r\n}\r\n\r\n/**\r\n * Inserts a fragment of HTML elements before a specified element in the DOM tree.\r\n * @param {Element} parent - The parent element where the fragment will be inserted.\r\n * @param {Node} insertBeforeNode - The element before which the fragment will be inserted.\r\n * @param {DocumentFragment | Element} fragment - The fragment of HTML elements to be inserted.\r\n * @returns {void}\r\n */\r\nfunction insertBefore(parent, insertBeforeNode, fragment) {\r\n  while (fragment.childNodes.length > 0) {\r\n    const child = fragment.firstChild;\r\n    parent.insertBefore(child, insertBeforeNode);\r\n    if (\r\n      child.nodeType === Node.ELEMENT_NODE\r\n    ) {\r\n      // TODO: process this later after all have been inserted because some code may expect all html to exist\r\n      // This type assertion is safe because of the check above\r\n      processElementAndChildren(/** @type Element*/(child));\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Replaces the outer HTML of a target element with the provided HTML string.\r\n *\r\n * @param {Element} targetElement - The target element whose outer HTML needs to be replaced.\r\n * @param {string} htmlString - The HTML string to replace the outer HTML of the target element.\r\n * @returns {void}\r\n */\r\nexport function swapOuterHTML(targetElement, htmlString) {\r\n  const fragment = parseHTML(htmlString);\r\n  const previousSibling = targetElement.previousSibling;\r\n  insertBefore(targetElement.parentElement, previousSibling, fragment);\r\n\r\n  // Remove the remaining HTML\r\n  // TODO: Maybe there's a faster way? Maybe using `Range` need to benchmark this\r\n  targetElement.remove();\r\n}\r\n\r\n/**\r\n * Replaces the HTML content of a target element with new HTML content.\r\n * @param {Element} targetElement - The element whose HTML content will be replaced.\r\n * @param {string} htmlString - The new HTML content to replace the old content with.\r\n * @returns {void}\r\n */\r\nexport function swapInnerHTML(targetElement, htmlString) {\r\n  // TODO: Support multiple strategies for swapping HTML\r\n  // TODO: Support full body refreshes and title changes\r\n\r\n  const fragment = parseHTML(htmlString);\r\n  const firstChild = targetElement.firstChild;\r\n\r\n  insertBefore(targetElement, firstChild, fragment);\r\n\r\n  // Remove the remaining HTML\r\n  // TODO: Maybe there's a faster way? Maybe using `Range` need to benchmark this\r\n  if (firstChild) {\r\n    while (firstChild.nextSibling) {\r\n      targetElement.removeChild(firstChild.nextSibling);\r\n    }\r\n    targetElement.removeChild(firstChild);\r\n    // TODO: Clean up existing elements including event handlers\r\n  }\r\n}", "import { swapInnerHTML } from \"./dom.js\";\r\n\r\n/**\r\n * @param {string} method\r\n * @param {RequestInfo | URL} url\r\n * @param {Element} swapTarget\r\n */\r\nexport async function handleFetch(method, url, swapTarget) {\r\n  // TODO: handle multiple swap types\r\n  const response = await fetch(url, {\r\n    method: method.toUpperCase(),\r\n  });\r\n\r\n  if (response.ok) {\r\n    const html = await response.text();\r\n    swapInnerHTML(swapTarget, html);\r\n  }\r\n}\r\n", "export const httpMethods = [\"get\", \"post\", \"put\", \"patch\", \"delete\", \"head\"];\n\nexport const methodSelector = httpMethods\n  .flatMap((method) => [`[oyc-${method}]`, `[data-oyc-${method}]`])\n  .join(\",\");\n\nexport const ignoreAttribute = \"oyc-ignore\";\n\nexport const oycAttributes = [\"oyc-trigger\", \"oyc-class\"];\n\nexport const oycAttributeSelector = oycAttributes\n  .flatMap((attribute) => [`[${attribute}]`, `[data-${attribute}]`])\n  .join(\",\");", "import { methodSelector, oycAttributeSelector } from \"./static.js\";\r\n\r\n/**\r\n * Finds all elements within the given element that match the method selector or the OYC attribute selector.\r\n * @param {Element} parent - The element to search within.\r\n * @returns {NodeListOf<Element>} - A list of matching elements.\r\n */\r\nexport function findOycChildren(parent) {\r\n  return parent.querySelectorAll(\r\n    methodSelector + \",\" + oycAttributeSelector\r\n  );\r\n}\r\n\r\n\r\nconst onElementExpression = new XPathEvaluator().createExpression('//*[@*[ starts-with(name(), \"oyc-on:\") or starts-with(name(), \"data-oyc-on:\") ] and not(@oyc-ignore) and not(@data-oyc-ignore)]');\r\n\r\n/**\r\n * Finds all elements within a given element that have an attribute starting with \"oyc-on:\" or \"data-oyc-on:\"\r\n * @param {Element} parent - The root element to start searching from. Defaults to the entire document.\r\n * @returns {Element[]} An array of matching nodes\r\n */\r\nexport function findOnElements(parent) {\r\n  // TODO: Check for faster alternatives\r\n  const xpathResults = onElementExpression.evaluate(\r\n    parent,\r\n    4 // UNORDERED_NODE_ITERATOR_TYPE\r\n  );\r\n\r\n  let element = null;\r\n  const elements = [];\r\n\r\n  /**\r\n   * To the best of my knowledge, all possible results are Elements.\r\n   * Here's a list of possible Nodes that are not Elements - none of these can have attributes:\r\n   * Text, Comment, Document, DocumentFragment\r\n   */\r\n  while ((element = xpathResults.iterateNext())) {\r\n    elements.push(element);\r\n  }\r\n  return /** @type {Element[]} */(elements);\r\n}\r\n\r\n/**\r\n * Checks if the given element has an attribute with the given name.\r\n * Also checks for the attribute with the \"data-\" prefix.\r\n *\r\n * @param {Element} element\r\n * @param {string} name\r\n * @returns boolean\r\n */\r\nexport function hasAttribute(element, name) {\r\n  return element.hasAttribute(name) || element.hasAttribute(\"data-\" + name);\r\n}\r\n\r\n/**\r\n * Gets the value of the given attribute on the given element.\r\n * Also checks for the attribute with the \"data-\" prefix.\r\n *\r\n * @param {Element} element\r\n * @param {string} name\r\n * @returns unknown\r\n */\r\nexport function getAttribute(element, name) {\r\n  return element.getAttribute(name) || element.getAttribute(\"data-\" + name);\r\n}\r\n\r\nconst oycDataAttribute = \"oyc-data\";\r\n\r\n// TODO: Figure out a way to type this\r\n/**\r\n * @param {Node} element\r\n */\r\nexport function getData(element) {\r\n  // An alternative to just adding this to the element is to use a WeakMap\r\n  // I'm unsure if that would make any significant difference in performance\r\n  // This is simpler to add \uD83E\uDD37\u200D\u2640\uFE0F\r\n  return element[oycDataAttribute] || {};\r\n}\r\n\r\n/**\r\n * Converts a time interval string to milliseconds.\r\n * @param {string} time - The time interval string.\r\n * @returns {number} The time in milliseconds.\r\n */\r\nexport function parseInterval(time) {\r\n  if (time === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  let value = parseFloat(time);\r\n  let unit = time.replace(value.toString(), \"\");\r\n\r\n  switch (unit) {\r\n    case \"ms\":\r\n      return value; // milliseconds\r\n    case \"s\":\r\n      return value * 1000; // seconds to milliseconds\r\n    case \"m\":\r\n      return value * 60000; // minutes to milliseconds\r\n    default:\r\n      console.warn(\"[OYC] Invalid time interval: \" + time);\r\n      return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Adds an event listener to the given element for the specified event.\r\n * @param {Element} element - The element to add the event listener to. Defaults to the document body.\r\n * @param {string} eventName - The name of the event to listen for.\r\n * @param {EventListener} listener - The listener function to call when the event is triggered.\r\n * @param {Modifier} [modifier] - The trigger object that describes how to handle the event.\r\n */\r\nexport function addEventListener(element, eventName, listener, modifier) {\r\n  if (!modifier || Object.keys(modifier).length === 0) {\r\n    element.addEventListener(eventName, listener);\r\n    return;\r\n  }\r\n\r\n  // If there is a modifier then wrap the listener function\r\n  const listenerWrapper = function (/** @type {Event} */ event) {\r\n    if (modifier.delay) {\r\n      setTimeout(() => {\r\n        listener(event);\r\n      }, modifier.delay);\r\n      return;\r\n    }\r\n    if (modifier.throttle) {\r\n      throw new Error(\"Throttle is not yet implemented\");\r\n    }\r\n    if (modifier.debounce) {\r\n      throw new Error(\"Debounce is not yet implemented\");\r\n    }\r\n\r\n    listener(event);\r\n  };\r\n  element.addEventListener(eventName, listenerWrapper, modifier);\r\n}\r\n\r\n/**\r\n * Removes an event listener from the specified element.\r\n * @param {Element} element - The element to remove the event listener from.\r\n * @param {string} eventName - The name of the event.\r\n * @param {EventListener} listener - The callback function to remove.\r\n */\r\nexport function removeEventListener(element, eventName, listener) {\r\n  element.removeEventListener(eventName, listener);\r\n}\r\n\r\nconst _defaultTrigger = {\r\n  event: \"click\",\r\n  modifiers: undefined,\r\n};\r\n\r\n/**\r\n * @typedef {Object} Modifier\r\n * @property {boolean} [once]\r\n * @property {boolean} [prevent]\r\n * @property {number} [delay]\r\n * @property {number} [throttle]\r\n * @property {number} [debounce]\r\n * @property {boolean} [capture]\r\n * @property {boolean} [passive]\r\n * @property {string} [from]\r\n */\r\n\r\n/**\r\n * @typedef {Object} Trigger\r\n * @property {string} event\r\n * @property {Modifier} modifiers\r\n */\r\n\r\n// The trigger string is a comma-separated list of triggers\r\n// These look like this \"[event] [modifier1] [modifier2] [modifier3]\"\r\n// TODO: add support for events like:\r\n//    - load\r\n//    - revealed - when it first scrolls into the viewport\r\n//    - intersect - when it intersects with another element\r\n// Modifiers can be:\r\n//    - once\r\n//    - prevent\r\n//    - poll:<time_interval> - can be in ms, s or m\r\n//    - delay:<time_interval> - can be in ms, s or m\r\n//    - throttle:<time_interval> - can be in ms, s or m\r\n//    - debounce:<time_interval> - can be in ms, s or m\r\n//    - capture\r\n//    - passive\r\n//    - from:<CSS Selector>\r\n// TODO: support \"changed\" event\r\n// TODO: support more selectors https://htmx.org/docs/#extended-css-selectors\r\n/**\r\n * Parses a trigger string into an object with event and modifiers.\r\n * @param {string} triggerString - The trigger string to parse.\r\n * @returns {Trigger | undefined} An object with the event name and an array of modifiers.\r\n */\r\nexport function parseTrigger(triggerString) {\r\n  if (!triggerString) {\r\n    return undefined;\r\n  }\r\n  // TODO: rewrite this to be more efficient\r\n  // Read it character by character and consume tokens instead\r\n  let parts = triggerString.split(\" \");\r\n\r\n  const event = parts[0];\r\n  /**\r\n   * @type {Modifier}\r\n   */\r\n  const modifiers = {};\r\n\r\n  for (let index = 1; index < parts.length; index++) {\r\n    const modifier = parts[index].trim();\r\n\r\n    if (!parts[index].trim()) {\r\n      continue;\r\n    }\r\n\r\n    // First we check for the simple modifiers\r\n    switch (modifier) {\r\n      case \"once\":\r\n      case \"prevent\":\r\n      case \"capture\":\r\n      case \"passive\": {\r\n        modifiers[modifier] = true;\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // If we get here, it's a more complex modifier\r\n    const complexPart = modifier.split(\":\");\r\n    const name = complexPart[0];\r\n    const value = complexPart[1];\r\n\r\n    switch (name) {\r\n      case \"poll\":\r\n      case \"delay\":\r\n      case \"throttle\":\r\n      case \"debounce\": {\r\n        modifiers[name] = parseInterval(value);\r\n        continue;\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    event,\r\n    modifiers,\r\n  };\r\n}\r\n\r\n/**\r\n * This function's only claim to fame is that it merges `defaultTrigger`\r\n * \r\n * @param {Element} element\r\n * @param {EventListener} listener\r\n */\r\nexport function parseAndAddTriggerHandler(element, listener) {\r\n  const trigger = {\r\n    ..._defaultTrigger,\r\n    ...parseTrigger(getAttribute(element, \"oyc-trigger\")),\r\n  };\r\n  addEventListener(element, trigger.event, listener, trigger.modifiers);\r\n}\r\n", "import { handleFetch } from \"./fetch.js\";\nimport { httpMethods } from \"./static.js\";\nimport { parseAndAddTriggerHandler, getAttribute } from \"./utils.js\";\n\n/**\n * @param {Element} element\n */\nexport function processHTTPAttributes(element) {\n  for (let index = 0; index < httpMethods.length; index++) {\n    const url = getAttribute(element, \"oyc-\" + httpMethods[index]);\n    if (url) {\n      parseAndAddTriggerHandler(element, (event) => {\n        // TODO: Disable this element's processing while the request is in progress\n        // add a boolean to the element?\n        void handleFetch(\n          httpMethods[index],\n          url,\n          // I didn't manage to override the Event interface in TS\n          /** @type {Element} */\n          // We are using target because, by default, the element that we have attached the event listener\n          // is the one to swap\n          (event.target) // TODO: allow us to set a different target for the swap\n        );\n      });\n    }\n  }\n}\n", "import { processHTTPAttributes } from \"./attributes.js\";\r\nimport { ignoreAttribute } from \"./static.js\";\r\nimport {\r\n  addEventListener,\r\n  findOycChildren,\r\n  findOnElements,\r\n  getAttribute,\r\n  getData,\r\n  parseTrigger,\r\n  removeEventListener,\r\n} from \"./utils.js\";\r\n\r\n// Reexport some utils for plugins\r\n// TODO: Reexport more\r\nexport { parseInterval } from './utils.js';\r\n\r\nexport class Oyc {\r\n  ready = document.readyState === \"complete\";\r\n  on = addEventListener;\r\n  off = removeEventListener;\r\n  getOycData = getData;\r\n  process = processElementAndChildren;\r\n\r\n  constructor() {\r\n    // Are we already loaded? This shouldn't happen since we recomment loading this script as a module\r\n    if (this.ready == false) {\r\n      document.addEventListener(\"readystatechange\", () => {\r\n        if (document.readyState === \"complete\") {\r\n          this.ready = true;\r\n        }\r\n      });\r\n    }\r\n\r\n    this.onReady(function () {\r\n      processElementAndChildren(document.body);\r\n      // TODO: emit custom event\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute a function now if DOMContentLoaded has fired, otherwise listen for it.\r\n   *\r\n   */\r\n  onReady(fn) {\r\n    // HTMX handles the following edge case so we should too.\r\n    //\r\n    // Checking readyState here is a failsafe in case the oyc script tag entered the DOM by\r\n    // some means other than the initial page load.\r\n    if (this.ready) {\r\n      fn();\r\n    } else {\r\n      document.addEventListener(\"readystatechange\", () => {\r\n        if (document.readyState === \"complete\") {\r\n          fn();\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Adds OYC specific listeners\r\n * \r\n * Note: this doesn't handle `oyc-on`. If you want that behavior please use `processElementAndChildren`\r\n * or `addCustomEventListeners`\r\n * This is because that uses a totally different selction mechanism\r\n * \r\n * @param {Element} element\r\n */\r\nexport function processElement(element) {\r\n  // Process HTTP Attributes\r\n  processHTTPAttributes(element);\r\n}\r\n\r\n/**\r\n * Adds all custom event handlers on an element and its children\r\n * Ex: \r\n * - oyc-on:click=\"topLevelFunctionName\"\r\n * - oyc-on:click=\"topLevelFunctionName\" oyc-trigger=\"click delay:2s\"\r\n * \r\n * @param {Element} element\r\n */\r\nfunction addCustomEventListeners(element) {\r\n  /**\r\n   * Find all the elements and add event handlers.\r\n   */\r\n  const elements = findOnElements(element);\r\n  for (let index = 0; index < elements.length; index++) {\r\n    const element = elements[index];\r\n\r\n    for (let index = 0; index < element.attributes.length; index++) {\r\n      const attribute = element.attributes[index];\r\n      if (\r\n        attribute.name.startsWith(\"oyc-on:\") ||\r\n        attribute.name.startsWith(\"data-oyc-on:\")\r\n      ) {\r\n        const event = attribute.name.slice(attribute.name.indexOf(\":\") + 1);\r\n        const listener = attribute.value;\r\n\r\n        // TODO: there is a limitation here in that we can't easily add event listeners\r\n        // when the listener is a function that is not a top-level function or when used inside\r\n        // another ES Module\r\n\r\n        // Yes, we only support top-level functions.\r\n        // No, we will not support eval.\r\n        const trigger = parseTrigger(getAttribute(element, \"oyc-trigger\"));\r\n        if (trigger) {\r\n          addEventListener(\r\n            element,\r\n            trigger.event,\r\n            window[listener],\r\n            trigger.modifiers\r\n          );\r\n        } else {\r\n          addEventListener(element, event, window[listener]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Process the given element and its children.\r\n * This means:\r\n *    - Add custom event listeres\r\n *    - Add HTTP event listeners\r\n *\r\n * @param {Element} element\r\n */\r\nexport function processElementAndChildren(element) {\r\n  // TODO: Add extra initialization for node like data\r\n  // TODO: Add hook for custom initialization per-node\r\n\r\n  if (getAttribute(element, ignoreAttribute)) {\r\n    return;\r\n  }\r\n  // Remove existing event listeners\r\n  // This may not be needed if we keep a hash of custom listeners\r\n  processElement(element);\r\n\r\n  const children = findOycChildren(element);\r\n  for (let i = 0; i < children.length; i++) {\r\n    processElement(children[i]);\r\n  }\r\n  \r\n  // It may be worth moving this inside processElement, but here the selector is very different\r\n  addCustomEventListeners(element);\r\n}\r\n\r\n/**\r\n * The Oyc instance.\r\n * @type {Oyc}\r\n */\r\nexport const oyc = new Oyc();\r\n\r\n// Don't touch `window` server-side\r\nif (typeof window !== \"undefined\") {\r\n  window.oyc = oyc;\r\n}\r\n"],
  "mappings": "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",
  "names": ["domParser", "parseHTML", "htmlString", "outputSelector", "parsedHTML", "insertBefore", "parent", "insertBeforeNode", "fragment", "child", "processElementAndChildren", "swapInnerHTML", "targetElement", "htmlString", "fragment", "parseHTML", "firstChild", "insertBefore", "handleFetch", "method", "url", "swapTarget", "response", "html", "swapInnerHTML", "httpMethods", "methodSelector", "method", "ignoreAttribute", "oycAttributes", "oycAttributeSelector", "attribute", "findOycChildren", "parent", "methodSelector", "oycAttributeSelector", "onElementExpression", "findOnElements", "xpathResults", "element", "elements", "getAttribute", "element", "name", "oycDataAttribute", "getData", "parseInterval", "time", "value", "addEventListener", "eventName", "listener", "modifier", "listenerWrapper", "event", "removeEventListener", "_defaultTrigger", "parseTrigger", "triggerString", "parts", "modifiers", "index", "complexPart", "parseAndAddTriggerHandler", "trigger", "processHTTPAttributes", "element", "index", "httpMethods", "url", "getAttribute", "parseAndAddTriggerHandler", "event", "handleFetch", "Oyc", "addEventListener", "removeEventListener", "getData", "processElementAndChildren", "fn", "processElement", "element", "processHTTPAttributes", "addCustomEventListeners", "elements", "findOnElements", "index", "attribute", "event", "listener", "trigger", "parseTrigger", "getAttribute", "ignoreAttribute", "children", "findOycChildren", "i", "oyc"]
}
