{
  "version": 3,
  "sources": ["../src/dom.js", "../src/fetch.js", "../src/static.js", "../src/utils.js", "../src/oyc.js"],
  "sourcesContent": ["// We reuse the DOMParser instead of creating a new one\nconst domParser = new DOMParser();\n\n/**\n * Parses an HTML string and returns a document fragment containing the parsed HTML.\n * @param {string} htmlString - The HTML string to parse.\n * @param {string} [outputSelector] - Optional CSS selector for selecting a specific element from the parsed HTML.\n * @returns {DocumentFragment | Element} - The parsed HTML as a document fragment or a selected element.\n */\nexport function parseHTML(htmlString, outputSelector) {\n  // TODO: Support full body refreshes and title changes\n  // We wrap the html string inside a body tag\n  // Looking at the htmx part of the code this appears to avoid some weirdness around parsing `table` tags and friends\n  // TODO: verify this assumption\n  // TODO: handle scripts\n  const parsedHTML = domParser.parseFromString(\n    `<body><template>${htmlString}</template></body>`,\n    \"text/html\",\n  ).querySelector(\"template\").content;\n\n  if (outputSelector) {\n    return parsedHTML.querySelector(outputSelector);\n  }\n\n  return parsedHTML;\n}\n\n/**\n * Inserts a fragment of DOM nodes before a specified node in the parent node.\n * Calls the provided callback function on each inserted element node.\n *\n * @param {Element} parent - The parent node where the fragment will be inserted.\n * @param {Node} insertBeforeNode - The node before which the fragment will be inserted.\n * @param {DocumentFragment | Element} fragment - The fragment of DOM nodes to be inserted.\n * @param {Function} onProcess - The callback function to be called on each inserted element node.\n * @returns {void}\n */\nfunction insertBefore(parent, insertBeforeNode, fragment, onProcess) {\n  console.log(onProcess, \"IS ONPROCES\\n\");\n  while (fragment.childNodes.length > 0) {\n    const child = fragment.firstChild;\n    parent.insertBefore(child, insertBeforeNode);\n    if (\n      child.nodeType === Node.ELEMENT_NODE\n    ) {\n      // TODO: process this later after all have been inserted because some code may expect all html to exist\n      // This type assertion is safe because of the check above\n      onProcess(/** @type Element*/ (child));\n    }\n  }\n}\n\n/**\n * Replaces the outer HTML of a target element with the provided HTML string.\n *\n * @param {Element} targetElement - The target element whose outer HTML needs to be replaced.\n * @param {string} htmlString - The HTML string to replace the outer HTML of the target element.\n * @param {Function} onProcess - The callback function to be called on each inserted element node.\n * @returns {void}\n */\nexport function swapOuterHTML(targetElement, htmlString, onProcess) {\n  const fragment = parseHTML(htmlString);\n  const previousSibling = targetElement.previousSibling;\n  insertBefore(targetElement.parentElement, previousSibling, fragment, onProcess);\n\n  // Remove the remaining HTML\n  // TODO: Maybe there's a faster way? Maybe using `Range` need to benchmark this\n  targetElement.remove();\n}\n\n/**\n * Replaces the HTML content of a target element with new HTML content.\n * @param {Element} targetElement - The element whose HTML content will be replaced.\n * @param {string} htmlString - The new HTML content to replace the old content with.\n * @param {Function} onProcess - The callback function to be called on each inserted element node.\n * @returns {void}\n */\nexport function swapInnerHTML(targetElement, htmlString, onProcess) {\n  // TODO: Support multiple strategies for swapping HTML\n  // TODO: Support full body refreshes and title changes\n\n  const fragment = parseHTML(htmlString);\n  const firstChild = targetElement.firstChild;\n\n  insertBefore(targetElement, firstChild, fragment, onProcess);\n\n  // Remove the remaining HTML\n  // TODO: Maybe there's a faster way? Maybe using `Range` need to benchmark this\n  if (firstChild) {\n    while (firstChild.nextSibling) {\n      targetElement.removeChild(firstChild.nextSibling);\n    }\n    targetElement.removeChild(firstChild);\n    // TODO: Clean up existing elements including event handlers\n  }\n}\n", "import { swapInnerHTML } from \"./dom.js\";\n\n/**\n * @param {string} method\n * @param {RequestInfo | URL} url\n * @param {Function} onProcess - The callback function to be called on each inserted element node.\n * @param {Element} swapTarget\n */\nexport async function handleFetch(method, url, swapTarget, onProcess) {\n  // TODO: handle multiple swap types\n  const response = await fetch(url, {\n    method: method.toUpperCase(),\n  });\n\n  if (response.ok) {\n    const html = await response.text();\n    swapInnerHTML(swapTarget, html, onProcess);\n  }\n}\n", "export const httpMethods = [\"get\", \"post\", \"put\", \"patch\", \"delete\", \"head\"];\n\nexport const methodSelector = httpMethods\n  .flatMap((method) => [`[oyc-${method}]`, `[data-oyc-${method}]`])\n  .join(\",\");\n\nexport const ignoreAttribute = \"oyc-ignore\";\n\nexport const oycAttributes = [\"oyc-trigger\"];\n\nexport const oycAttributeSelector = oycAttributes\n  .flatMap((attribute) => [`[${attribute}]`, `[data-${attribute}]`])\n  .join(\",\");\n", "const oycDataAttribute = \"oyc-data\";\n\n// TODO: Figure out a way to type this\n/**\n * @param {Node} element\n */\nexport function getData(element) {\n  // An alternative to just adding this to the element is to use a WeakMap\n  // I'm unsure if that would make any significant difference in performance\n  // This is simpler to add \uD83E\uDD37\u200D\u2640\uFE0F\n  return element[oycDataAttribute] || {};\n}\n\n/**\n * Converts a time interval string to milliseconds.\n * @param {string} time - The time interval string.\n * @returns {number} The time in milliseconds.\n */\nexport function parseInterval(time) {\n  if (time === undefined) {\n    return undefined;\n  }\n\n  let value = parseFloat(time);\n  let unit = time.replace(value.toString(), \"\");\n\n  switch (unit) {\n    case \"ms\":\n      return value; // milliseconds\n    case \"s\":\n      return value * 1000; // seconds to milliseconds\n    case \"m\":\n      return value * 60000; // minutes to milliseconds\n    default:\n      console.warn(\"[OYC] Invalid time interval: \" + time);\n      return undefined;\n  }\n}\n\n/**\n * Adds an event listener to the given element for the specified event.\n * @param {Element} element - The element to add the event listener to. Defaults to the document body.\n * @param {string} eventName - The name of the event to listen for.\n * @param {EventListener} listener - The listener function to call when the event is triggered.\n * @param {Modifier} [modifier] - The trigger object that describes how to handle the event.\n */\nexport function addEventListener(element, eventName, listener, modifier) {\n  if (!modifier || Object.keys(modifier).length === 0) {\n    element.addEventListener(eventName, listener);\n    return;\n  }\n\n  // If there is a modifier then wrap the listener function\n  const listenerWrapper = function(/** @type {Event} */ event) {\n    if (modifier.delay) {\n      setTimeout(() => {\n        listener(event);\n      }, modifier.delay);\n      return;\n    }\n    if (modifier.throttle) {\n      throw new Error(\"Throttle is not yet implemented\");\n    }\n    if (modifier.debounce) {\n      throw new Error(\"Debounce is not yet implemented\");\n    }\n\n    listener(event);\n  };\n  element.addEventListener(eventName, listenerWrapper, modifier);\n}\n\n/**\n * Removes an event listener from the specified element.\n * @param {Element} element - The element to remove the event listener from.\n * @param {string} eventName - The name of the event.\n * @param {EventListener} listener - The callback function to remove.\n */\nexport function removeEventListener(element, eventName, listener) {\n  element.removeEventListener(eventName, listener);\n}\n\nconst _defaultTrigger = {\n  event: \"click\",\n  modifiers: undefined,\n};\n\n/**\n * @typedef {Object} Modifier\n * @property {boolean} [once]\n * @property {boolean} [prevent]\n * @property {number} [delay]\n * @property {number} [throttle]\n * @property {number} [debounce]\n * @property {boolean} [capture]\n * @property {boolean} [passive]\n * @property {string} [from]\n */\n\n/**\n * @typedef {Object} Trigger\n * @property {string} event\n * @property {Modifier} modifiers\n */\n\n// The trigger string is a comma-separated list of triggers\n// These look like this \"[event] [modifier1] [modifier2] [modifier3]\"\n// TODO: add support for events like:\n//    - load\n//    - revealed - when it first scrolls into the viewport\n//    - intersect - when it intersects with another element\n// Modifiers can be:\n//    - once\n//    - prevent\n//    - poll:<time_interval> - can be in ms, s or m\n//    - delay:<time_interval> - can be in ms, s or m\n//    - throttle:<time_interval> - can be in ms, s or m\n//    - debounce:<time_interval> - can be in ms, s or m\n//    - capture\n//    - passive\n//    - from:<CSS Selector>\n// TODO: support \"changed\" event\n// TODO: support more selectors https://htmx.org/docs/#extended-css-selectors\n/**\n * Parses a trigger string into an object with event and modifiers.\n * @param {string} triggerString - The trigger string to parse.\n * @returns {Trigger | undefined} An object with the event name and an array of modifiers.\n */\nexport function parseTrigger(triggerString) {\n  if (!triggerString) {\n    return undefined;\n  }\n  // TODO: rewrite this to be more efficient\n  // Read it character by character and consume tokens instead\n  let parts = triggerString.split(\" \");\n\n  const event = parts[0];\n  /**\n   * @type {Modifier}\n   */\n  const modifiers = {};\n\n  for (let index = 1; index < parts.length; index++) {\n    const modifier = parts[index].trim();\n\n    if (!parts[index].trim()) {\n      continue;\n    }\n\n    // First we check for the simple modifiers\n    switch (modifier) {\n      case \"once\":\n      case \"prevent\":\n      case \"capture\":\n      case \"passive\": {\n        modifiers[modifier] = true;\n        continue;\n      }\n    }\n\n    // If we get here, it's a more complex modifier\n    const complexPart = modifier.split(\":\");\n    const name = complexPart[0];\n    const value = complexPart[1];\n\n    switch (name) {\n      case \"poll\":\n      case \"delay\":\n      case \"throttle\":\n      case \"debounce\": {\n        modifiers[name] = parseInterval(value);\n        continue;\n      }\n    }\n  }\n\n  return {\n    event,\n    modifiers,\n  };\n}\n\n/**\n * This function's only claim to fame is that it merges `defaultTrigger`\n *\n * @param {Element} element\n * @param {EventListener} listener\n */\nexport function parseAndAddTriggerHandler(element, listener) {\n  const trigger = {\n    ..._defaultTrigger,\n    ...parseTrigger(element.getAttribute(\"oyc-trigger\")),\n  };\n  addEventListener(element, trigger.event, listener, trigger.modifiers);\n}\n", "import { handleFetch } from \"./fetch.js\";\nimport { httpMethods, ignoreAttribute, methodSelector, oycAttributeSelector } from \"./static.js\";\nimport { addEventListener, getData, parseAndAddTriggerHandler, parseTrigger, removeEventListener } from \"./utils.js\";\n\n// Reexport some utils for plugins\n// TODO: Reexport more\nexport { parseInterval } from \"./utils.js\";\n\nconst onElementExpression = new XPathEvaluator().createExpression(\n  \"//*[@*[ starts-with(name(), \\\"oyc-on:\\\") or starts-with(name(), \\\"data-oyc-on:\\\") ] and not(@oyc-ignore) and not(@data-oyc-ignore)]\",\n);\n\nexport class Oyc {\n  ready = document.readyState === \"complete\";\n  on = addEventListener;\n  off = removeEventListener;\n  process = this.processElementAndChildren;\n  getOycData = getData;\n  /**\n   * @type {any[]}\n   */\n  extensions = [];\n  cssSelector = methodSelector + \",\" + oycAttributeSelector;\n\n  constructor() {\n    // Are we already loaded? This shouldn't happen since we recomment loading this script as a module\n    if (this.ready == false) {\n      document.addEventListener(\"readystatechange\", () => {\n        if (document.readyState === \"complete\") {\n          this.ready = true;\n        }\n      });\n    }\n\n    this.onReady(() => {\n      this.processElementAndChildren(document.body);\n      // TODO: emit custom event\n    });\n  }\n\n  registerExtension(extension) {\n    if (extension.init) {\n      extension.init(this);\n    }\n    this.cssSelector += extension.attribute\n      ? \",[\" + extension.attribute + \"]\"\n      : \",\"\n        + extension.attributes\n          .map((/** @type {string} */ attribute) => \"[\" + attribute + \"]\")\n          .join(\",\");\n    this.extensions.push(extension);\n  }\n\n  /**\n   * Execute a function now if DOMContentLoaded has fired, otherwise listen for it.\n   * @param { () => void } fn\n   */\n  onReady(fn) {\n    // HTMX handles the following edge case so we should too.\n    //\n    // Checking readyState here is a failsafe in case the oyc script tag entered the DOM by\n    // some means other than the initial page load.\n    if (this.ready) {\n      fn();\n    } else {\n      document.addEventListener(\"readystatechange\", () => {\n        if (document.readyState === \"complete\") {\n          fn();\n        }\n      });\n    }\n  }\n\n  /**\n   * Adds OYC specific listeners\n   *\n   * Note: this doesn't handle `oyc-on`. If you want that behavior please use `processElementAndChildren`\n   * or `addCustomEventListeners`\n   * This is because that uses a totally different selction mechanism\n   *\n   * @param {Element} element\n   */\n  processElement(element) {\n    // Process HTTP Attributes\n    this.processHTTPAttributes(element);\n\n    for (let index = 0; index < this.extensions.length; index++) {\n      this.extensions[index].process(element);\n    }\n  }\n\n  /**\n   * Adds all custom event handlers on an element and its children\n   * Ex:\n   * - oyc-on:click=\"topLevelFunctionName\"\n   * - oyc-on:click=\"topLevelFunctionName\" oyc-trigger=\"click delay:2s\"\n   *\n   * @param {Element} element\n   */\n  addCustomEventListeners(element) {\n    /**\n     * Find all the elements and add event handlers.\n     */\n    const elements = this.findOnElements(element);\n    for (let index = 0; index < elements.length; index++) {\n      const element = elements[index];\n\n      for (let index = 0; index < element.attributes.length; index++) {\n        const attribute = element.attributes[index];\n        if (\n          attribute.name.startsWith(\"oyc-on:\")\n          || attribute.name.startsWith(\"data-oyc-on:\")\n        ) {\n          const event = attribute.name.slice(attribute.name.indexOf(\":\") + 1);\n          const listener = attribute.value;\n\n          // TODO: there is a limitation here in that we can't easily add event listeners\n          // when the listener is a function that is not a top-level function or when used inside\n          // another ES Module\n\n          // Yes, we only support top-level functions.\n          // No, we will not support eval.\n          const trigger = parseTrigger(element.getAttribute(\"oyc-trigger\"));\n          if (trigger) {\n            addEventListener(\n              element,\n              trigger.event,\n              window[listener],\n              trigger.modifiers,\n            );\n          } else {\n            addEventListener(element, event, window[listener]);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Process the given element and its children.\n   * This means:\n   *    - Add custom event listeres\n   *    - Add HTTP event listeners\n   *\n   * @param {Element} element\n   */\n  processElementAndChildren(element) {\n    // TODO: Add extra initialization for node like data\n    // TODO: Add hook for custom initialization per-node\n\n    if (element.getAttribute(ignoreAttribute)) {\n      return;\n    }\n\n    console.log(\"THIS THIS\", this);\n    // Remove existing event listeners\n    // This may not be needed if we keep a hash of custom listeners\n    this.processElement(element);\n\n    const children = this.findOycChildren(element);\n    for (let i = 0; i < children.length; i++) {\n      this.processElement(children[i]);\n    }\n\n    // It may be worth moving this inside processElement, but here the selector is very different\n    this.addCustomEventListeners(element);\n  }\n\n  /**\n   * Finds all elements within the given element that match the method selector or the OYC attribute selector.\n   * @param {Element} parent - The element to search within.\n   * @returns {NodeListOf<Element>} - A list of matching elements.\n   */\n  findOycChildren(parent) {\n    return parent.querySelectorAll(this.cssSelector);\n  }\n\n  /**\n   * Finds all elements within a given element that have an attribute starting with \"oyc-on:\" or \"data-oyc-on:\"\n   * @param {Element} parent - The root element to start searching from. Defaults to the entire document.\n   * @returns {Element[]} An array of matching nodes\n   */\n  findOnElements(parent) {\n    // TODO: Check for faster alternatives\n    const xpathResults = onElementExpression.evaluate(\n      parent,\n      4, // UNORDERED_NODE_ITERATOR_TYPE\n    );\n\n    let element = null;\n    const elements = [];\n\n    /**\n     * To the best of my knowledge, all possible results are Elements.\n     * Here's a list of possible Nodes that are not Elements - none of these can have attributes:\n     * Text, Comment, Document, DocumentFragment\n     */\n    while ((element = xpathResults.iterateNext())) {\n      elements.push(element);\n    }\n    return /** @type {Element[]} */ (elements);\n  }\n\n  /**\n   * @param {Element} element\n   */\n  processHTTPAttributes(element) {\n    for (let index = 0; index < httpMethods.length; index++) {\n      const url = element.getAttribute(\"oyc-\" + httpMethods[index]);\n      if (url) {\n        parseAndAddTriggerHandler(element, (event) => {\n          console.log(\"THIS THIS THIS HIST HISTSADDSA \", this);\n          // TODO: Disable this element's processing while the request is in progress\n          // add a boolean to the element?\n          void handleFetch(\n            httpMethods[index],\n            url,\n            // I didn't manage to override the Event interface in TS\n            /** @type {Element} */\n            // We are using target because, by default, the element that we have attached the event listener\n            // is the one to swap\n            (event.target),\n            this.processElementAndChildren.bind(this), // TODO: allow us to set a different target for the swap\n          );\n        });\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["domParser", "parseHTML", "htmlString", "outputSelector", "parsedHTML", "insertBefore", "parent", "insertBeforeNode", "fragment", "onProcess", "child", "swapInnerHTML", "targetElement", "htmlString", "onProcess", "fragment", "parseHTML", "firstChild", "insertBefore", "handleFetch", "method", "url", "swapTarget", "onProcess", "response", "html", "swapInnerHTML", "httpMethods", "methodSelector", "method", "ignoreAttribute", "oycAttributes", "oycAttributeSelector", "attribute", "oycDataAttribute", "getData", "element", "parseInterval", "time", "value", "addEventListener", "eventName", "listener", "modifier", "listenerWrapper", "event", "removeEventListener", "_defaultTrigger", "parseTrigger", "triggerString", "parts", "modifiers", "index", "complexPart", "name", "parseAndAddTriggerHandler", "trigger", "onElementExpression", "Oyc", "addEventListener", "removeEventListener", "getData", "methodSelector", "oycAttributeSelector", "extension", "attribute", "fn", "element", "index", "elements", "event", "listener", "trigger", "parseTrigger", "ignoreAttribute", "children", "i", "parent", "xpathResults", "httpMethods", "url", "parseAndAddTriggerHandler", "handleFetch"]
}
